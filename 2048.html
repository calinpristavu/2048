<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>2048</title>
    <style>
        #board {
            border-collapse: collapse;

            tr {
                td {
                    width: min(15vw, 15vh);
                    height: min(15vw, 15vh);

                    border: 1px solid #ccc;

                    text-align: center;
                    vertical-align: middle;

                    span {
                        transition: all 2s ease;
                        font-size: min(7vw, 7vh);
                    }
                }
            }
        }
    </style>
</head>
<body>
<table id="board">
    <colgroup>
        <col>
        <col>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
        </tr>
        <tr>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
        </tr>
        <tr>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
        </tr>
        <tr>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
            <td><span></span></td>
        </tr>
    </tbody>
</table>

<script type="application/javascript">
  seed()
  seed()
  let moved = false

  document.addEventListener('keyup', ev => {
    switch (ev.key) {
      case 'ArrowUp':
      case 'w':
        chunkCellsByColumn(Array.from(document.querySelectorAll("#board tr td"))).forEach(row => performMoveOnVector(row))
        break
      case 'ArrowLeft':
      case 'a':
        document.querySelectorAll("#board tr").forEach(tr => performMoveOnVector(tr.children))
        break
      case 'ArrowDown':
      case 's':
        chunkCellsByColumn(Array.from(document.querySelectorAll("#board tr td"))).forEach(row => performMoveOnVector(row.reverse()))
        break
      case 'ArrowRight':
      case 'd':
        document.querySelectorAll("#board tr").forEach(tr => performMoveOnVector(Array.from(tr.children).reverse()))
        break
      default:
        return
    }

    if (moved) {
      moved = false
      seed()
    }
  })

  function mergeCells(from, to) {
    if (canMergeCells(from, to) < 0) {
      return
    }

    const fromVal = Number(from.firstElementChild.textContent)
    let toVal = Number(to.firstElementChild.textContent)

    // TODO: animations

    from.firstElementChild.textContent = ""
    toVal += fromVal
    to.firstElementChild.textContent = String(toVal)

    moved = true
  }

  function canMergeCells(from, to) {
    const fromVal = Number(from.firstElementChild.textContent)
    let toVal = Number(to.firstElementChild.textContent)

    if (fromVal === 0) {
      return -1
    }

    if (toVal === 0) {
      return 0
    }

    return fromVal === toVal ? 1 : -1
  }

  function seed() {
    const emptyCells = document.querySelectorAll('#board tr td span:empty')

    if (emptyCells.length === 0) {
      alert("GAME OVER")
      return
    }

    const randomIdx = Math.floor(Math.random() * (emptyCells.length))

    emptyCells[randomIdx].textContent = String((Math.round(Math.random()) + 1) * 2)
  }

  function chunkCellsByColumn(arr) {
    if (arr.length === 0) {
      return arr
    }

    const chunkSize = arr[0].parentElement.parentElement.childElementCount

    return arr.reduce((acc, cell, i) => {
      let columnIndex = i % chunkSize;
      if (typeof acc[columnIndex] === "undefined") {
        acc[columnIndex] = Array()
      }

      acc[columnIndex].push(cell)

      return acc
    }, [])
  }

  function performMoveOnVector(vec) {
    Object.entries(vec).forEach(([k, v]) => {
      if (Number(k) === 0) {
        return
      }

      let candidateCell = null
      for (let i = Number(k) - 1; i >= 0; i--) {
        let mergeStatus = canMergeCells(v, vec[i]);
        if (-1 === mergeStatus) {
          break
        }

        candidateCell = vec[i]

        if (1 === mergeStatus) {
          break
        }
      }

      candidateCell !== null && mergeCells(v, candidateCell)
    })
  }
</script>

</body>
</html>